---
alwaysApply: true
---

# Project Rules for Simple but Maintainable MERN Applications

## 1. General Rules

**Tech Stack**: The project must be built using the MERN stack: MongoDB (with Mongoose), Express.js, React, and Node.js.

**Project Structure**: The project must use a monorepo structure with two top-level directories: `client` for the React front-end and `server` for the Node.js/Express back-end.

**Code Linting and Formatting**: Upon project creation, configure ESLint and Prettier for the entire project and use a standard style guide like Airbnb.

**Modern JavaScript**: Use `const` and `let` for variable declarations. Never use `var`.

**File Naming**: Use kebab-case for folders and utility files (e.g., `my-component.js`). React components can use either kebab-case or PascalCase (e.g., `UserProfile.js` is fine).

**Naming Conventions**: All classes and React components must use PascalCase. All variables, functions, and properties must use camelCase.

**DRY Principle**: Avoid code duplication. Extract common logic into reusable functions or components.

**Single Responsibility Principle**: Each component, function, and module must have a single, well-defined purpose.

**API Routes**: All API routes on the server must be prefixed with `/api/`.

**Version Control**: Generate a `.gitignore` file and adhere to a standard for commit messages (e.g., Conventional Commits).

**Development Speed**: Prioritize getting features working quickly over perfect architecture. Refactor later if needed.

**Testing Focus**: Since this is for testing, focus on rapid prototyping. Use console.log for debugging, simple error messages, and minimal validation.

**Feature Scope**: Only implement what is explicitly requested. Do not add extra features, buttons, or functionality unless specifically asked. Focus on the exact requirements and suggest improvements only when asked for guidance.

## 2. Front-end Rules (React & UI)

**UI Framework**: The front-end must use the Tailwind CSS utility-first framework for styling.

**UI Primitives**: Use Headless UI for all complex UI primitives like modals, dialogs, and flyouts. Headless UI will manage functionality and accessibility, while Tailwind CSS will handle styling.

**UI Components**: Leverage Headless UI's pre-built components (Dialog, Menu, Listbox, etc.) to build interfaces quickly without custom accessibility work.

**Headless UI Usage**: 
- Use `@headlessui/react` for all interactive components (modals, dropdowns, tabs)
- Combine with Tailwind for instant styling
- Leverage their accessibility features to focus on functionality

**Tailwind Best Practices**:
- Use Tailwind's built-in spacing/color system
- Create simple component variants with conditional classes
- Use `@apply` sparingly - prefer utility classes in JSX

**CSS Utility Classes Approach**:
- **Centralized Styling**: All reusable element styles must be defined in `src/styles/components.css` using Tailwind's `@apply` directive
- **Semantic Classes**: Use semantic class names instead of repeating Tailwind utilities across components
- **Variant System**: Create modifier classes for variants (e.g., `-primary`, `-danger`, `-success`, `-error`)
- **Size Modifiers**: Use size classes for consistent sizing (e.g., `-sm`, `-md`, `-lg`)
- **No Heavy Components**: Avoid creating React components for simple styling - use CSS classes instead
- **Class Composition**: Combine base classes with modifiers (e.g., `className="element element-primary element-md"`)
- **Consistent Naming**: Follow the pattern: `element` for base styles, `element-variant` for variants, `element-size` for sizes

**Architecture**: For simple projects, a flat structure is acceptable. For larger projects, adopt a feature-based architecture organizing the `src` directory by feature (e.g., `features/auth`, `features/posts`).

**Component Abstraction**: For styling, prioritize CSS utility classes over React components. Only create React components for complex interactive behavior, not for simple styling patterns.

**Consistent Class Ordering**: Utility classes must be ordered to improve readability. The preferred order is: Layout, Sizing, Spacing, Typography, Backgrounds & Borders, and Interactivity/States.

**Config-Driven Customization**: Avoid using arbitrary values in class names. All custom design tokens for colors, fonts, spacing, and breakpoints must be defined and extended within the `tailwind.config.js` file.

**Error Handling**: For simple projects, basic try-catch in components is acceptable. For larger projects, isolate API calls within a dedicated API service layer to handle network-level errors gracefully.

**State Management**: Use React's built-in state management (`useState`, `useContext`) unless a global state library is explicitly requested.

**Design Principles**:
- **Clean & Minimal**: Prioritize clean, uncluttered interfaces with plenty of white space
- **Consistent Spacing**: Use Tailwind's spacing scale consistently (4, 8, 12, 16, 24, 32, 48, 64, 96, 128)
- **Typography Hierarchy**: Use clear typography scales with proper contrast ratios
- **Color Palette**: Stick to a limited, cohesive color palette (max 3-4 primary colors)
- **Visual Hierarchy**: Use size, weight, and color to create clear information hierarchy
- **Mobile-First**: Design for mobile first, then enhance for larger screens
- **Accessibility**: Ensure proper contrast ratios (4.5:1 for normal text, 3:1 for large text)
- **Loading States**: Always include loading states and empty states for better UX
- **Error States**: Design clear, helpful error messages and states

**Component Design Guidelines**:
- **Single Purpose**: Each component should have one clear purpose
- **Reusable**: Design components to be reusable across different contexts
- **Composable**: Build complex UIs by combining simple, focused components
- **Consistent Props**: Use consistent prop naming and structure across similar components
- **Default States**: Provide sensible defaults for all component props

**Component Naming Convention**:
- **Prefix Pattern**: Use descriptive prefixes for component groups to improve organization (e.g., `SettingsGeneral`, `SettingsOnboarding`, `AuthLogin`, `AuthRegister`, `UserProfile`, `UserDashboard`)
- **Grouping**: Components with similar functionality should share a common prefix to group them alphabetically and make their purpose clear
- **Consistency**: Follow this pattern for all component groups to maintain organization and discoverability across the entire codebase

**Modular Architecture Rules**:
- **Component Separation**: Never put multiple distinct UI features in a single component file
- **Feature Isolation**: Each major feature should have its own component directory
- **Logic Separation**: Keep business logic separate from UI components - use custom hooks for complex state management
- **API Layer**: Create dedicated API service files for all external data fetching
- **Utility Functions**: Extract reusable logic into separate utility files
- **Constants**: Define all magic numbers, strings, and configuration in dedicated constants files

**File Organization Standards**:
- **Component Structure**: Each component should be in its own file with matching directory name
- **Index Files**: Use index.js files to create clean import paths for component directories
- **Naming Convention**: Component files must match their export name exactly
- **Co-location**: Keep related files (styles, tests, types) close to their components when possible

**Reusability Requirements**:
- **Prop Interface**: Every reusable component must have a clear, documented prop interface
- **Default Props**: Provide sensible defaults for all optional props
- **Composition over Configuration**: Prefer composition patterns over complex prop configurations
- **Generic Components**: Avoid creating generic styling components (Button, Input, Card) - use CSS utility classes instead for better performance and simplicity
- **Hook Extraction**: Extract complex component logic into custom hooks for reusability

**Maintainability Standards**:
- **Max File Size**: Keep component files under 400 lines - split larger components unless it logically makes sense to keep them.
- **Max Function Size**: Keep functions under 50 lines - extract smaller functions
- **Dependency Management**: Minimize component dependencies - prefer prop drilling over complex context
- **Error Boundaries**: Implement error boundaries for component isolation
- **Type Safety**: Use PropTypes or TypeScript for prop validation in production code

## 3. Back-end Rules (Node.js & Express)

**Centralized Error Handling**: For simple projects, basic error handling is acceptable. No need to implement a dedicated Express middleware for global error handling.

**Informative Error Messages**: Return clear, helpful error messages from the API without exposing sensitive details.

**Folder Structure**: The server directory should contain `src` as the main source folder, with sub-directories for models, routes, and controllers.

**Environment Variables**: All sensitive information, such as the MongoDB connection string, must be stored in a `.env` file and accessed using the dotenv package.

**RESTful Principles**: API routes should follow RESTful conventions (e.g., GET `/api/items` to get all items, POST `/api/items` to create an item).

**Database**: Use simple Mongoose schemas without complex validation for testing. Add validation only when needed.

**API Design**: Keep APIs simple - don't over-engineer with complex middleware unless necessary.

**Backend Modularity Rules**:
- **Route Separation**: Each feature should have its own route file (e.g., `authRoutes.js`, `userRoutes.js`)
- **Controller Pattern**: Use controller functions to separate route logic from business logic
- **Service Layer**: Create service files for complex business logic and database operations
- **Middleware Organization**: Group related middleware in separate files
- **Model Separation**: Each data model should be in its own file with clear schema definition
- **Utility Functions**: Extract common database operations and business logic into utility files
- **Configuration Management**: Centralize all configuration in dedicated config files
- **Error Handling**: Create consistent error response utilities and use them across all routes

**Code Organization Standards**:
- **Feature-Based Structure**: Organize server code by features when the project grows beyond simple CRUD
- **Dependency Injection**: Use dependency injection patterns for better testability
- **Environment Separation**: Keep development, testing, and production configurations separate
- **Database Connection**: Centralize database connection logic in a dedicated file
- **Validation Layer**: Create reusable validation middleware for common data validation needs
