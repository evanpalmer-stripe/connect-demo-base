---
alwaysApply: true
---

# Project Rules for Simple but Maintainable MERN Applications

## 1. General Rules

**Tech Stack**: The project must be built using the MERN stack: MongoDB (with Mongoose), Express.js, React, and Node.js.

**Project Structure**: The project must use a monorepo structure with two top-level directories: `client` for the React front-end and `server` for the Node.js/Express back-end.

**Code Linting and Formatting**: Upon project creation, configure ESLint and Prettier for the entire project and use a standard style guide like Airbnb.

**Modern JavaScript**: Use `const` and `let` for variable declarations. Never use `var`.

**File Naming**: Use kebab-case for folders and utility files (e.g., `my-component.js`). React components can use either kebab-case or PascalCase (e.g., `UserProfile.js` is fine).

**Naming Conventions**: All classes and React components must use PascalCase. All variables, functions, and properties must use camelCase.

**DRY Principle**: Avoid code duplication. Extract common logic into reusable functions or components.

**Single Responsibility Principle**: Each component, function, and module must have a single, well-defined purpose.

**API Routes**: All API routes on the server must be prefixed with `/api/`.

**Version Control**: Generate a `.gitignore` file and adhere to a standard for commit messages (e.g., Conventional Commits).

**Development Speed**: Prioritize getting features working quickly over perfect architecture. Refactor later if needed.

**Testing Focus**: Since this is for testing, focus on rapid prototyping. Use console.log for debugging, simple error messages, and minimal validation.

**Feature Scope**: Only implement what is explicitly requested. Do not add extra features, buttons, or functionality unless specifically asked. Focus on the exact requirements and suggest improvements only when asked for guidance.

**Minimal Implementation Rule**: When asked to install packages or make simple changes, do ONLY what was requested. Do not create additional files, configurations, or implementations unless explicitly asked. For example:
- If asked to "install stripe", only run the npm install commands
- If asked to "add a button", only add the button, not styling, state management, or event handlers
- If asked to "create a component", only create the basic component structure
- Do not assume additional requirements or "helpful" extras

**Agent Mode vs Ask Mode**: 
- **Agent Mode**: Only propose code changes, file edits, or tool usage when explicitly in agent mode. This is when the user wants me to take action and make changes to the codebase.
- **Ask Mode**: In ask mode, focus purely on conversation, explanation, and learning. Do not propose any code changes, file edits, or tool usage. Simply chat, explain concepts, and help the user understand things without making any modifications to the project.

## 2. Front-end Rules (React & UI)

**UI Framework**: The front-end must use the Tailwind CSS utility-first framework for styling.

**UI Primitives**: Use Headless UI for all complex UI primitives like modals, dialogs, and flyouts. Headless UI will manage functionality and accessibility, while Tailwind CSS will handle styling.

**UI Components**: Leverage Headless UI's pre-built components (Dialog, Menu, Listbox, etc.) to build interfaces quickly without custom accessibility work.

**Headless UI Usage**: 
- Use `@headlessui/react` for all interactive components (modals, dropdowns, tabs)
- Combine with Tailwind for instant styling
- Leverage their accessibility features to focus on functionality

**Tailwind Best Practices**:
- Use Tailwind's built-in spacing/color system
- Create simple component variants with conditional classes
- Use `@apply` sparingly - prefer utility classes in JSX

**CSS Utility Classes Approach**:
- **Centralized Styling**: All reusable element styles must be defined in `src/styles/components.css` using Tailwind's `@apply` directive
- **Semantic Classes**: Use semantic class names instead of repeating Tailwind utilities across components
- **Variant System**: Create modifier classes for variants (e.g., `-primary`, `-danger`, `-success`, `-error`)
- **Size Modifiers**: Use size classes for consistent sizing (e.g., `-sm`, `-md`, `-lg`)
- **No Heavy Components**: Avoid creating React components for simple styling - use CSS classes instead
- **Class Composition**: Combine base classes with modifiers (e.g., `className="element element-primary element-md"`)
- **Consistent Naming**: Follow the pattern: `element` for base styles, `element-variant` for variants, `element-size` for sizes

**Architecture**: For simple projects, a flat structure is acceptable. For larger projects, adopt a feature-based architecture organizing the `src` directory by feature (e.g., `features/auth`, `features/posts`).

**Component Abstraction**: For styling, prioritize CSS utility classes over React components. Only create React components for complex interactive behavior, not for simple styling patterns.

**Consistent Class Ordering**: Utility classes must be ordered to improve readability. The preferred order is: Layout, Sizing, Spacing, Typography, Backgrounds & Borders, and Interactivity/States.

**Config-Driven Customization**: Avoid using arbitrary values in class names. All custom design tokens for colors, fonts, spacing, and breakpoints must be defined and extended within the `tailwind.config.js` file.

**Error Handling**: For simple projects, basic try-catch in components is acceptable. For larger projects, isolate API calls within a dedicated API service layer to handle network-level errors gracefully.

**State Management**: Use React's built-in state management (`useState`, `useContext`) unless a global state library is explicitly requested.

**Centralized Settings Management**: All control panel settings must be managed through the centralized Settings Context pattern:
- **Context Pattern**: Use React Context with useReducer for all settings state management
- **Provider Wrapper**: Wrap the entire app with SettingsProvider to make settings available globally
- **Custom Hooks**: Use specific hooks (useGeneralSettings, useOnboardingSettings, etc.) instead of direct context access
- **Automatic Persistence**: All settings must automatically persist to localStorage via the context
- **No Local State**: Settings components must NOT use local useState for settings - always use context hooks
- **Action Creators**: Use action creator functions (updateGeneral, updateOnboarding) instead of direct dispatch calls
- **Immutable Updates**: Always use spread operators to create new state objects, never mutate existing state
- **Error Boundaries**: Context must include proper error handling for localStorage operations
- **Default Values**: Provide sensible default values for all settings in the initial state
- **Type Safety**: Use consistent action types and payload structures for all setting updates

**Design Principles**:
- **Clean & Minimal**: Prioritize clean, uncluttered interfaces with plenty of white space
- **Consistent Spacing**: Use Tailwind's spacing scale consistently (4, 8, 12, 16, 24, 32, 48, 64, 96, 128)
- **Typography Hierarchy**: Use clear typography scales with proper contrast ratios
- **Color Palette**: Stick to a limited, cohesive color palette (max 3-4 primary colors)
- **Visual Hierarchy**: Use size, weight, and color to create clear information hierarchy
- **Mobile-First**: Design for mobile first, then enhance for larger screens
- **Accessibility**: Ensure proper contrast ratios (4.5:1 for normal text, 3:1 for large text)
- **Loading States**: Always include loading states and empty states for better UX
- **Error States**: Design clear, helpful error messages and states

**Component Design Guidelines**:
- **Single Purpose**: Each component should have one clear purpose
- **Reusable**: Design components to be reusable across different contexts
- **Composable**: Build complex UIs by combining simple, focused components
- **Consistent Props**: Use consistent prop naming and structure across similar components
- **Default States**: Provide sensible defaults for all component props

**Component Naming Convention**:
- **Prefix Pattern**: Use descriptive prefixes for component groups to improve organization (e.g., `SettingsGeneral`, `SettingsOnboarding`, `AuthLogin`, `AuthRegister`, `UserProfile`, `UserDashboard`)
- **Grouping**: Components with similar functionality should share a common prefix to group them alphabetically and make their purpose clear
- **Consistency**: Follow this pattern for all component groups to maintain organization and discoverability across the entire codebase

**Modular Architecture Rules**:
- **Component Separation**: Never put multiple distinct UI features in a single component file
- **Feature Isolation**: Each major feature should have its own component directory
- **Logic Separation**: Keep business logic separate from UI components - use custom hooks for complex state management
- **API Layer**: Create dedicated API service files for all external data fetching
- **Utility Functions**: Extract reusable logic into separate utility files
- **Constants**: Define all magic numbers, strings, and configuration in dedicated constants files

**File Organization Standards**:
- **Component Structure**: Each component should be in its own file with matching directory name
- **Index Files**: Use index.js files to create clean import paths for component directories
- **Naming Convention**: Component files must match their export name exactly
- **Co-location**: Keep related files (styles, tests, types) close to their components when possible

**Reusability Requirements**:
- **Prop Interface**: Every reusable component must have a clear, documented prop interface
- **Default Props**: Provide sensible defaults for all optional props
- **Composition over Configuration**: Prefer composition patterns over complex prop configurations
- **Generic Components**: Avoid creating generic styling components (Button, Input, Card) - use CSS utility classes instead for better performance and simplicity
- **Hook Extraction**: Extract complex component logic into custom hooks for reusability

**Maintainability Standards**:
- **Max File Size**: Keep component files under 400 lines - split larger components unless it logically makes sense to keep them.
- **Max Function Size**: Keep functions under 50 lines - extract smaller functions
- **Dependency Management**: Minimize component dependencies - prefer prop drilling over complex context
- **Error Boundaries**: Implement error boundaries for component isolation
- **Type Safety**: Use PropTypes or TypeScript for prop validation in production code

**React Router and Layout Standards**:
- **Layout Route Pattern**: Always use React Router's nested route pattern with Layout components and `<Outlet />`
- **Shared Layout**: All pages must use the same Layout component for consistent header, container, and card styling
- **No Full-Screen Layouts**: Page components must NOT use `min-h-screen`, `flex`, `items-center`, or `justify-center` - these are handled by the Layout
- **Consistent Spacing**: Use `space-y-6` for main content containers to match existing pages
- **Typography Consistency**: Use `text-xl font-medium` for page headings to match the established pattern
- **Route Structure**: All routes must be nested under a parent Layout route using the pattern:
  ```jsx
  <Route path="/" element={<Layout />}>
    <Route index element={<HomePage />} />
    <Route path="new-page" element={<NewPage />} />
  </Route>
  ```
- **Page Component Structure**: All page components must follow this structure:
  ```jsx
  const PageName = () => {
    return (
      <div className="space-y-6">
        <div className="text-center">
          <h2 className="text-xl font-medium text-gray-900 mb-2">
            Page Title
          </h2>
          <p className="text-gray-600">
            Page description
          </p>
        </div>
        {/* Page content */}
      </div>
    );
  };
  ```
- **Navigation Links**: Use React Router's `Link` component for all internal navigation
- **Catch-All Routes**: Always include a catch-all route (`path="*"`) that redirects to the homepage
- **Layout Component**: The Layout component must handle all shared UI elements (header, container, card wrapper) and use `<Outlet />` for child route content

## 3. Back-end Rules (Node.js & Express)

**Centralized Error Handling**: For simple projects, basic error handling is acceptable. No need to implement a dedicated Express middleware for global error handling.

**Informative Error Messages**: Return clear, helpful error messages from the API without exposing sensitive details.

**Folder Structure**: The server directory should contain `src` as the main source folder, with sub-directories for models, routes, and controllers.

**Environment Variables**: All sensitive information, such as the MongoDB connection string, must be stored in a `.env` file and accessed using the dotenv package.

**RESTful Principles**: API routes should follow RESTful conventions (e.g., GET `/api/items` to get all items, POST `/api/items` to create an item).

**Database**: Use simple Mongoose schemas without complex validation for testing. Add validation only when needed.

**API Design**: Keep APIs simple - don't over-engineer with complex middleware unless necessary.

**Backend Modularity Rules**:
- **Route Separation**: Each feature should have its own route file (e.g., `authRoutes.js`, `userRoutes.js`)
- **Controller Pattern**: Use controller functions to separate route logic from business logic
- **Service Layer**: Create service files for complex business logic and database operations
- **Middleware Organization**: Group related middleware in separate files
- **Model Separation**: Each data model should be in its own file with clear schema definition
- **Utility Functions**: Extract common database operations and business logic into utility files
- **Configuration Management**: Centralize all configuration in dedicated config files
- **Error Handling**: Create consistent error response utilities and use them across all routes

**Code Organization Standards**:
- **Feature-Based Structure**: Organize server code by features when the project grows beyond simple CRUD
- **Dependency Injection**: Use dependency injection patterns for better testability
- **Environment Separation**: Keep development, testing, and production configurations separate
- **Database Connection**: Centralize database connection logic in a dedicated file
- **Validation Layer**: Create reusable validation middleware for common data validation needs
